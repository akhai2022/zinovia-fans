# AWS Deployment Runbook (zinovia.ai)

Production-ready deployment for zinovia-fans on AWS: **dedicated new VPC** (not default), ECS Fargate (API, Web, Worker), RDS Postgres, S3 + CloudFront for media, SQS for media jobs, Route53 + ACM for app.zinovia.ai, api.zinovia.ai, media.zinovia.ai.

**Environments:** staging (`stg-app`, `stg-api`, `stg-media`) and prod (`app`, `api`, `media`).

**VPC:** By default Terraform creates a **new dedicated VPC** (2–3 AZs, public subnets for ALB, private subnets for ECS and RDS, NAT gateways). We do **not** use the AWS default VPC. Optional escape hatch: set `use_existing_vpc = true` and provide `vpc_id`, `public_subnet_ids`, `private_subnet_ids` in tfvars for experiments; staging and prod tfvars keep `use_existing_vpc = false`.

---

## Prerequisites

- AWS CLI installed and configured (or use GitHub OIDC in CI)
- Terraform >= 1.6
- Docker (for building images)
- **Route53 hosted zone for zinovia.ai** (create in AWS Console if it doesn’t exist)

```bash
aws sts get-caller-identity
```

---

## 1. Bootstrap (first-time)

### 1.1 Create Route53 hosted zone (if needed)

If you don’t have a hosted zone for `zinovia.ai`:

1. AWS Console → Route53 → Hosted zones → Create hosted zone.
2. Domain: `zinovia.ai`. Note the **Zone ID**.
3. Delegate your domain to the NS records Route53 gives you (at your registrar).

### 1.2 Terraform init and apply (staging)

From **repo root**:

```bash
cd infra/aws/terraform

# Backend: use local first; for team use uncomment backend "s3" in versions.tf and create bucket + DynamoDB table
terraform init

# Staging
terraform plan -var-file=env/staging.tfvars -out=staging.plan
terraform apply staging.plan
```

If you have an existing hosted zone ID, set it in `env/staging.tfvars`:

```hcl
route53_zone_id = "Z0123456789ABCDEF"
```

Accept the plan and wait for VPC, subnets, NAT gateways, RDS, ECR, S3, SQS, CloudFront, ACM, ECS cluster and services, ALB, Route53 records.

**Or use Make (from repo root):**

```bash
make aws-stg-plan   # plan staging
make aws-stg-apply  # apply staging
make aws-stg-outputs # print URLs and vpc_id
```

### 1.3 Set secrets (Secrets Manager)

Terraform creates secrets with placeholders. Set real values (never commit):

```bash
# JWT (required)
aws secretsmanager put-secret-value --secret-id zinovia-fans-staging-jwt-secret --secret-string "your-32-char-jwt-secret"

# CSRF (required)
aws secretsmanager put-secret-value --secret-id zinovia-fans-staging-csrf-secret --secret-string "your-csrf-secret"

# Stripe (optional)
aws secretsmanager put-secret-value --secret-id zinovia-fans-staging-stripe-secret-key --secret-string "sk_live_..."
aws secretsmanager put-secret-value --secret-id zinovia-fans-staging-stripe-webhook-secret --secret-string "whsec_..."
```

DB password is generated by Terraform and stored in Secrets Manager and in the `database-url` secret; no need to set it manually unless you rotate.

---

## 2. Build and push images

Build API, Web, and Worker images and push to ECR. Use the ECR URLs from Terraform output:

```bash
cd infra/aws/terraform
API_ECR=$(terraform output -raw ecr_api_url)
WEB_ECR=$(terraform output -raw ecr_web_url)
WORKER_ECR=$(terraform output -raw ecr_worker_url)
AWS_REGION=$(terraform output -raw aws_region 2>/dev/null || echo "us-east-1")

# Login
aws ecr get-login-password --region $AWS_REGION | docker login --username AWS --password-stdin $API_ECR

# Build and push (from repo root)
cd ../..
docker build -f infra/docker/api/Dockerfile -t $API_ECR:latest .
docker push $API_ECR:latest

docker build -f infra/docker/web/Dockerfile --build-arg NEXT_PUBLIC_API_BASE_URL=https://stg-api.zinovia.ai -t $WEB_ECR:latest .
docker push $WEB_ECR:latest

docker build -f infra/docker/worker/Dockerfile -t $WORKER_ECR:latest .
docker push $WORKER_ECR:latest
```

---

## 3. Run migrations (one-off ECS task)

Terraform defines a **migrate** task definition (`zinovia-fans-staging-migrate` / `zinovia-fans-prod-migrate`) that runs `alembic upgrade head` using the API image. Run it after deploy:

```bash
cd infra/aws/terraform
CLUSTER=$(terraform output -raw ecs_cluster_name)
TASK_DEF=$(terraform output -raw migrate_task_definition)
SUBNET_IDS=$(terraform output -json private_subnet_ids | jq -r 'join(",")')
SG_ID=$(terraform output -raw ecs_security_group_id)

aws ecs run-task \
  --cluster $CLUSTER \
  --task-definition $TASK_DEF \
  --launch-type FARGATE \
  --network-configuration "awsvpcConfiguration={subnets=[$SUBNET_IDS],securityGroups=[$SG_ID],assignPublicIp=DISABLED}" \
  --region us-east-1
```

Check status:

```bash
aws ecs list-tasks --cluster $CLUSTER --family $TASK_DEF --region us-east-1
```

---

## 4. Deploy (update ECS services)

After pushing new images, force a new deployment so ECS pulls the latest image:

```bash
aws ecs update-service --cluster zinovia-fans-staging-cluster --service zinovia-fans-staging-api --force-new-deployment
aws ecs update-service --cluster zinovia-fans-staging-cluster --service zinovia-fans-staging-web --force-new-deployment
aws ecs update-service --cluster zinovia-fans-staging-cluster --service zinovia-fans-staging-worker --force-new-deployment
```

---

## 5. Verification

- **API health**
  ```bash
  curl -s https://stg-api.zinovia.ai/health
  # Expect: {"status":"ok"}
  ```

- **Web**
  - Open https://stg-app.zinovia.ai in a browser. Home and navigation should load.

- **Media CDN**
  - Upload an image or video via the app, then open the media URL (should be https://stg-media.zinovia.ai/...).
  - For MP4, verify in DevTools that requests use `Range` and response is `206 Partial Content` where expected.

- **Database**
  - RDS endpoint: `terraform -C infra/aws/terraform output rds_endpoint`. Connect via bastion or Session Manager and run `SELECT 1` in DB `zinovia`.

---

## 5b. Terraform plan sanity (confirm dedicated VPC)

After `terraform plan` or `apply`, verify we are **not** using the default VPC:

```bash
cd infra/aws/terraform
terraform output vpc_id
# Must NOT be vpc-0f645619e2e32d202 (or your account's default VPC). Should be a new ID like vpc-0abc123...

terraform output nat_gateway_ids
# Should list 1 (staging) or 2 (prod) NAT gateway IDs when use_existing_vpc = false
```

In the plan output, confirm:

- **RDS:** `publicly_accessible = false` (RDS must be private).
- **ECS services:** `network_configuration.subnets` uses private subnet IDs (same as `terraform output private_subnet_ids`), and `assign_public_ip = false`.

---

## 6. Rollback

- **ECS:** Redeploy previous task revision or update service to a previous task definition revision.
- **Terraform:** Revert changes and `terraform apply` (avoid changing RDS deletion protection or destructive changes).
- **Migrations:** Alembic does not auto-downgrade; run a manual downgrade if required and document the revision.

---

## 7. Cost notes (staging)

- Staging uses small sizes: db.t3.micro, 256–512 CPU for ECS, single NAT, PriceClass_100 CloudFront. Expect roughly tens of dollars per month depending on traffic.
- Prod uses larger RDS, Multi-AZ, and deletion protection; see `env/prod.tfvars`.

---

## 8. GitHub Actions (CI/CD)

Workflows: `.github/workflows/aws-staging.yml`, `.github/workflows/aws-prod.yml`.

- **Staging:** Triggered on push to `main` (or workflow_dispatch). Builds API/Web/Worker images, pushes to ECR, forces ECS deployment, runs migration task.
- **Prod:** Manual only (`workflow_dispatch`).

**Setup:** Use GitHub OIDC (no static AWS keys):

1. In AWS IAM create an OIDC identity provider: provider URL `https://token.actions.githubusercontent.com`, audience `sts.amazonaws.com`.
2. Create a role that trusts `token.actions.githubusercontent.com` with condition on your repo (e.g. `repo:OWNER/zinovia-fans`). Attach policies: ECR push, ECS UpdateService, ECS RunTask, Secrets Manager read if needed.
3. In GitHub repo Settings → Secrets: add `AWS_ROLE_ARN_STAGING` and `AWS_ROLE_ARN_PROD` with the role ARNs.

---

## 9. Exact commands to deploy staging (new VPC)

Staging and prod use a **dedicated new VPC** (`use_existing_vpc = false` in tfvars). Never attach to the default VPC.

```bash
# From repo root
make aws-stg-plan
make aws-stg-apply

# Confirm VPC is not default
make aws-stg-outputs
# Check vpc_id is NOT vpc-0f645619e2e32d202 (or your account default)

# Set secrets (section 1.3), build/push images (section 2), run migration (section 3), force deploy (section 4), verify (section 5)
```

Or without Make:

```bash
cd infra/aws/terraform
terraform init -backend=false
terraform apply -var-file=env/staging.tfvars
terraform output vpc_id   # must not be default VPC ID
```

---

## Key Terraform outputs (staging)

| Output | Description |
|--------|-------------|
| `api_url` | https://stg-api.zinovia.ai |
| `app_url` | https://stg-app.zinovia.ai |
| `media_cdn_url` / `cdn_base_url` | https://stg-media.zinovia.ai (CDN for media) |
| `vpc_id` | **Dedicated VPC ID** — must not be default (e.g. not vpc-0f645619e2e32d202) |
| `nat_gateway_ids` | NAT gateway IDs (1 for staging, 2 for prod when new VPC) |
| `public_subnet_ids` | Public subnets (ALB) |
| `private_subnet_ids` | Private subnets (ECS, RDS) |
| `ecr_api_url` / `ecr_web_url` / `ecr_worker_url` | ECR repository URLs |
| `rds_endpoint` | RDS host:port |
| `media_bucket_id` | S3 media bucket name |
| `media_jobs_queue_url` | SQS queue URL |
| `ecs_cluster_name` | ECS cluster for run-task and update-service |
| `migrate_task_definition` | Task definition family for one-off migrations |
